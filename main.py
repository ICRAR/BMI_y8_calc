import os
import pandas as pd
import io
from fastapi import FastAPI, Request, Form, File, UploadFile, HTTPException
from fastapi.responses import HTMLResponse, FileResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
from typing import List, Optional
import csv
import json

# Import the BMI calculation functions
from run.run import add_y1y5_bmiz, calculate_y8_bmi
from bmizscore.zscore import get_bmiz_singlevalue as get_y5_bmiz
from pygrowup import Observation as get_y1_bmifa

# Create FastAPI app
app = FastAPI(
    title="Year 8 BMI Prediction Tool",
    description="A web application for predicting Year 8 BMI using different prediction models",
    version="1.0.0"
)

# Create directories for static files and templates if they don't exist
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)

# Mount static files directory
app.mount("/static", StaticFiles(directory="static"), name="static")

# Set up templates
templates = Jinja2Templates(directory="templates")

# Load variable descriptions from codes.csv
def load_variable_descriptions():
    descriptions = {}
    values = {}
    with open("calculator/codes.csv", "r") as f:
        reader = csv.DictReader(f)
        for row in reader:
            descriptions[row["name"]] = row["description"]
            if row["values"]:
                values[row["name"]] = [v.strip() for v in row["values"].split("\n")]
    return descriptions, values

variable_descriptions, variable_values = load_variable_descriptions()

# Define the variables for each mode
mode_variables = {
    "good": [
        'occupcode_m_0',
        'hhincome_0',
        'y5_a5',
        'y5_a6',
        'y5_a7',
        'y5_a8',
        'y5_a9',
        'y5_a10',
        'y5_bmiz',
        'preg_gain'
    ],
    "better": [
        'occupcode_m_0',
        'agebirth_m_y',
        'height_m',
        'mode_delivery',
        'height_f1',
        'hhincome_0',
        'solid_food',
        'ga_wt2',
        'y1_a10',
        'y5_a5',
        'y5_a6',
        'y5_a7',
        'y5_a8',
        'y5_a9',
        'y5_a10',
        'y5_bmiz',
        'y1_bmifa',
        'ga_us',
        'prepreg_cig',
        'preg_gain'
    ]
}

# Define the required variables for calculating derived variables
derived_variables = {
    "y5_bmiz": ["y5_agemos", "sex", "y5_a2", "y5_a1"],
    "y1_bmifa": ["y1_agemos", "sex", "y1_a2", "y1_a1"]
}

# Get all required variables for a mode
def get_required_variables(mode):
    # Get the variables for the mode
    required = set(mode_variables[mode])
    
    # Add variables needed for derived variables
    for var in mode_variables[mode]:
        if var in derived_variables:
            required.update(derived_variables[var])
    
    # Remove y1_bmifa and y5_bmiz as they will be generated by the code
    required.discard('y1_bmifa')
    required.discard('y5_bmiz')
    
    # Group variables by category
    other_vars = []
    y1_vars = []
    y5_vars = []
    
    for var in required:
        if var.startswith('y1_'):
            y1_vars.append(var)
        elif var.startswith('y5_'):
            y5_vars.append(var)
        else:
            other_vars.append(var)
    
    # Sort each group alphabetically for consistency
    other_vars.sort()
    y1_vars.sort()
    y5_vars.sort()
    
    # Combine the groups in the specified order
    return other_vars + y1_vars + y5_vars

# Create a template CSV file for a given mode
def create_template_csv(mode):
    required_vars = get_required_variables(mode)
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(required_vars)
    return output.getvalue()

# Process a single sample
def process_single_sample(data, mode):
    # Convert to DataFrame with a single row
    df = pd.DataFrame([data])
    
    # Calculate derived variables
    df = add_y1y5_bmiz(df, mode)
    
    # Calculate Year 8 BMI
    df = calculate_y8_bmi(df, mode)
    
    return df['y8_bmi'].iloc[0]

# Process a batch of samples
def process_batch(file, mode):
    # Read the CSV file
    df = pd.read_csv(file)
    
    # Calculate derived variables
    df = add_y1y5_bmiz(df, mode)
    
    # Calculate Year 8 BMI
    df = calculate_y8_bmi(df, mode)
    
    return df

# Routes
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {
        "request": request,
        "good_variables": [(var, variable_descriptions.get(var, "")) for var in get_required_variables("good")],
        "better_variables": [(var, variable_descriptions.get(var, "")) for var in get_required_variables("better")],
        "variable_values": variable_values
    })

@app.get("/api/variables/{mode}")
async def get_variables(mode: str):
    if mode not in ["good", "better"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    variables = []
    for var in get_required_variables(mode):
        variable_info = {
            "name": var,
            "description": variable_descriptions.get(var, ""),
        }
        if var in variable_values:
            variable_info["values"] = variable_values[var]
        variables.append(variable_info)
    
    return {"variables": variables}

@app.get("/api/template/{mode}")
async def get_template(mode: str, request: Request):
    if mode not in ["good", "better"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    content = create_template_csv(mode)
    
    return StreamingResponse(
        io.StringIO(content),
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename=template_{mode}.csv"}
    )

@app.post("/api/predict/single")
async def predict_single(mode: str = Form(...), data: str = Form(...)):
    if mode not in ["good", "better"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    try:
        # Parse the JSON data
        data_dict = json.loads(data)
        
        # Check if all required variables are present
        required_vars = get_required_variables(mode)
        missing_vars = [var for var in required_vars if var not in data_dict]
        
        if missing_vars:
            raise HTTPException(
                status_code=400, 
                detail=f"Missing required variables: {', '.join(missing_vars)}"
            )
        
        # Process the data
        result = process_single_sample(data_dict, mode)
        
        return {"y8_bmi": result}
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON data format")
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error processing single prediction: {str(e)}\n{error_details}")
        raise HTTPException(status_code=400, detail=f"Error processing data: {str(e)}")

@app.post("/api/predict/batch")
async def predict_batch(mode: str = Form(...), file: UploadFile = File(...)):
    if mode not in ["good", "better"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    try:
        # Read the file content
        content = await file.read()
        
        # Check if file is empty
        if len(content) == 0:
            raise HTTPException(status_code=400, detail="Empty file uploaded")
        
        # Process the data
        try:
            result_df = process_batch(io.BytesIO(content), mode)
        except pd.errors.EmptyDataError:
            raise HTTPException(status_code=400, detail="CSV file is empty or improperly formatted")
        except pd.errors.ParserError:
            raise HTTPException(status_code=400, detail="Invalid CSV format")
        
        # Check if required columns are present
        required_vars = get_required_variables(mode)
        missing_cols = [var for var in required_vars if var not in result_df.columns]
        
        if missing_cols:
            raise HTTPException(
                status_code=400, 
                detail=f"Missing required columns in CSV: {', '.join(missing_cols)}"
            )
        
        # Convert the result to CSV
        output = io.StringIO()
        result_df.to_csv(output, index=False)
        
        return StreamingResponse(
            io.StringIO(output.getvalue()),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename=result_{mode}.csv"}
        )
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error processing batch prediction: {str(e)}\n{error_details}")
        raise HTTPException(status_code=400, detail=f"Error processing data: {str(e)}")

# Run the application
if __name__ == "__main__":
    import uvicorn
    import os
    
    # Get port from environment variable or use default (8080)
    port = int(os.environ.get("PORT", 8080))
    
    # Run the server with the configured port
    uvicorn.run(app, host="0.0.0.0", port=port)