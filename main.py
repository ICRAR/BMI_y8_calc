#   Copyright (c) 2025. UWA (in the framework of the ICRAR)
#  #
#   Redistribution and use in source and binary forms, with or without modification, are permitted
#   provided that the following conditions are met:
#  #
#   1. Redistributions of source code must retain the above copyright notice, this list of conditions and
#   the following disclaimer.
#  #
#   2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
#   and the following disclaimer in the documentation and/or other materials provided with the distribution.
#  #
#   3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or
#   promote products derived from this software without specific prior written permission.
#  #
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import pandas as pd
import io
from fastapi import FastAPI, Request, Form, File, UploadFile, HTTPException
from fastapi.responses import HTMLResponse, FileResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
from typing import List, Optional
import csv
import json

# Import the BMI calculation functions
from run.run import add_y1y5_bmiz, calculate_y8_bmi
from bmizscore.zscore import get_bmiz_singlevalue as get_y5_bmiz
from pygrowup import Observation as get_y1_bmifa

# Create FastAPI app
app = FastAPI(
    title="Year 8 BMI Prediction Tool",
    description="A web application for predicting Year 8 BMI using different prediction models",
    version="1.0.0"
)

# Create directories for static files and templates if they don't exist
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)

# Mount static files directory
app.mount("/static", StaticFiles(directory="static"), name="static")

# Set up templates
templates = Jinja2Templates(directory="templates")

# Load variable descriptions from codes.csv
def load_variable_descriptions():
    descriptions = {}
    values = {}
    with open("calculator/codes.csv", "r") as f:
        reader = csv.DictReader(f)
        for row in reader:
            descriptions[row["name"]] = row["description"]
            if row["values"]:
                values[row["name"]] = [v.strip() for v in row["values"].split("\n")]
    return descriptions, values

variable_descriptions, variable_values = load_variable_descriptions()

# Define the variables for each mode
mode_variables = {
    "simple": [
        'occupcode_m_0',
        'hhincome_0',
        'y1_bmifa',
        'y5_a5',
        'y5_a6',
        'y5_a7',
        'y5_a8',
        'y5_a9',
        'y5_a10',
        'y5_bmiz',
        'preg_gain'
    ],
    "comprehensive": [
        'occupcode_m_0',
        'agebirth_m_y',
        'height_m',
        'mode_delivery',
        'height_f1',
        'hhincome_0',
        'solid_food',
        'ga_wt2',
        'y1_a10',
        'y5_a5',
        'y5_a6',
        'y5_a7',
        'y5_a8',
        'y5_a9',
        'y5_a10',
        'y5_bmiz',
        'y1_bmifa',
        'ga_us',
        'prepreg_cig',
        'preg_gain'
    ]
}

# Define the required variables for calculating derived variables
derived_variables = {
    "y5_bmiz": ["y5_agemos", "sex", "y5_a2", "y5_a1"],
    "y1_bmifa": ["y1_agemos", "sex", "y1_a2", "y1_a1"]
}

# Get all required variables for a mode
def get_required_variables(mode):
    # Get the variables for the mode
    required = set(mode_variables[mode])
    
    # Add variables needed for derived variables
    for var in mode_variables[mode]:
        if var in derived_variables:
            required.update(derived_variables[var])
    
    # Remove y1_bmifa and y5_bmiz as they will be generated by the code
    required.discard('y1_bmifa')
    required.discard('y5_bmiz')
    
    # Group variables by category
    other_vars = []
    y1_vars = []
    y5_vars = []
    
    for var in required:
        if var.startswith('y1_'):
            y1_vars.append(var)
        elif var.startswith('y5_'):
            y5_vars.append(var)
        else:
            other_vars.append(var)
    
    # Sort each group alphabetically for consistency
    other_vars.sort()
    y1_vars.sort()
    y5_vars.sort()
    
    # Combine the groups in the specified order
    return other_vars + y1_vars + y5_vars

# Create a template CSV file for a given mode
def create_template_csv(mode):
    required_vars = get_required_variables(mode)
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(required_vars)
    return output.getvalue()

# Process a single sample
def process_single_sample(data, mode):
    # Convert to DataFrame with a single row
    df = pd.DataFrame([data])
    
    # Calculate derived variables
    df = add_y1y5_bmiz(df, mode)
    
    # Calculate Year 8 BMI
    df = calculate_y8_bmi(df, mode)
    
    return df['y8_bmi'].iloc[0]

# Process a batch of samples
def process_batch(file, mode):
    # Read the CSV file
    df = pd.read_csv(file)
    
    # Calculate derived variables
    df = add_y1y5_bmiz(df, mode)
    
    # Calculate Year 8 BMI
    df = calculate_y8_bmi(df, mode)
    
    return df

# Routes
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {
        "request": request,
        "simple_variables": [(var, variable_descriptions.get(var, "")) for var in get_required_variables("simple")],
        "comprehensive_variables": [(var, variable_descriptions.get(var, "")) for var in get_required_variables("comprehensive")],
        "variable_values": variable_values
    })

@app.get("/api/variables/{mode}")
async def get_variables(mode: str):
    if mode not in ["simple", "comprehensive"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    variables = []
    for var in get_required_variables(mode):
        variable_info = {
            "name": var,
            "description": variable_descriptions.get(var, ""),
        }
        if var in variable_values:
            variable_info["values"] = variable_values[var]
        variables.append(variable_info)
    
    return {"variables": variables}

@app.get("/api/template/{mode}")
async def get_template(mode: str, request: Request):
    if mode not in ["simple", "comprehensive"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    content = create_template_csv(mode)
    
    return StreamingResponse(
        io.StringIO(content),
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename=template_{mode}.csv"}
    )

@app.post("/api/predict/single")
async def predict_single(mode: str = Form(...), data: str = Form(...)):
    if mode not in ["simple", "comprehensive"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    try:
        # Parse the JSON data
        data_dict = json.loads(data)
        
        # Check if all required variables are present
        required_vars = get_required_variables(mode)
        missing_vars = [var for var in required_vars if var not in data_dict]
        
        if missing_vars:
            raise HTTPException(
                status_code=400, 
                detail=f"Missing required variables: {', '.join(missing_vars)}"
            )
        
        # Process the data
        result = process_single_sample(data_dict, mode)
        
        return {"y8_bmi": result}
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON data format")
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error processing single prediction: {str(e)}\n{error_details}")
        raise HTTPException(status_code=400, detail=f"Error processing data: {str(e)}")

@app.post("/api/predict/batch")
async def predict_batch(mode: str = Form(...), file: UploadFile = File(...)):
    if mode not in ["simple", "comprehensive"]:
        raise HTTPException(status_code=400, detail="Invalid mode")
    
    try:
        # Read the file content
        content = await file.read()
        
        # Check if file is empty
        if len(content) == 0:
            raise HTTPException(status_code=400, detail="Empty file uploaded")
        
        # Read the original file to get the original columns
        original_df = pd.read_csv(io.BytesIO(content))
        original_columns = original_df.columns.tolist()
        
        # Process the data
        try:
            result_df = process_batch(io.BytesIO(content), mode)
        except pd.errors.EmptyDataError:
            raise HTTPException(status_code=400, detail="CSV file is empty or improperly formatted")
        except pd.errors.ParserError:
            raise HTTPException(status_code=400, detail="Invalid CSV format")
        
        # Check if required columns are present
        required_vars = get_required_variables(mode)
        missing_cols = [var for var in required_vars if var not in result_df.columns]
        
        if missing_cols:
            raise HTTPException(
                status_code=400, 
                detail=f"Missing required columns in CSV: {', '.join(missing_cols)}"
            )
        
        # Create a new DataFrame with only the original columns plus y8_bmi
        final_df = original_df.copy()
        final_df['y8_bmi'] = result_df['y8_bmi']
        
        # Convert the result to CSV
        output = io.StringIO()
        final_df.to_csv(output, index=False)
        
        return StreamingResponse(
            io.StringIO(output.getvalue()),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename=result_{mode}.csv"}
        )
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error processing batch prediction: {str(e)}\n{error_details}")
        raise HTTPException(status_code=400, detail=f"Error processing data: {str(e)}")

# Run the application
if __name__ == "__main__":
    import uvicorn
    import os
    import socket
    import argparse
    import sys
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Run the BMI Year 8 Prediction Tool server")
    parser.add_argument("--port", type=int, help="Port to run the server on (default: 8080 or PORT env var)")
    parser.add_argument("--host", type=str, default="localhost", help="Host to bind the server to (default: 0.0.0.0)")
    parser.add_argument("--auto-port", action="store_true", help="Automatically find an available port if the specified port is in use")
    args = parser.parse_args()
    
    # Get port from command line args, environment variable, or use default (8080)
    port = args.port if args.port is not None else int(os.environ.get("PORT", 8080))
    host = args.host
    
    # Function to check if a port is available
    def is_port_available(host, port):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind((host, port))
                return True
            except socket.error:
                return False
    
    # Try to find an available port if auto-port is enabled
    if args.auto_port and not is_port_available(host, port):
        print(f"Port {port} is already in use. Searching for an available port...")
        for test_port in range(port + 1, port + 100):
            if is_port_available(host, test_port):
                print(f"Found available port: {test_port}")
                port = test_port
                break
        else:
            print(f"Error: Could not find an available port in range {port+1}-{port+100}")
            sys.exit(1)
    
    try:
        # Run the server with the configured port
        print(f"Starting server on {host}:{port}")
        uvicorn.run(app, host=host, port=port)
    except OSError as e:
        if "address already in use" in str(e).lower():
            print(f"Error: Port {port} is already in use. Try using a different port with --port or enable --auto-port to automatically find an available port.")
            print(f"Example: python main.py --port 8081")
            print(f"Example: python main.py --auto-port")
        else:
            print(f"Error starting server: {e}")
        sys.exit(1)